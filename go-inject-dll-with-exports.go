package main

import (
	"fmt"
	"os"
	"strconv"
	"syscall"
	"unsafe"
)

const (
	FALSE                     = 0
	PROCESS_QUERY_INFORMATION = 0x0400
	PROCESS_VM_WRITE          = 0x0020
	PROCESS_VM_OPERATION      = 0x0008
	PROCESS_CREATE_THREAD     = 0x0002
	PAGE_EXECUTE_READWRITE    = 0x40
	PAGE_READ_WRITE           = 0x00000004
	MEM_RESERVE               = 0x00002000
	MEM_COMMIT                = 0x00001000
	MEM_RELEASE               = 0x8000
	PROCESS_ALL_ACCESS        = PROCESS_QUERY_INFORMATION | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD
)

var (
	targetDll          = "C:\\gob-server.dll"
	dllLength          = len(targetDll)
	kernel32           = syscall.NewLazyDLL("kernel32.dll")
	loadLibraryA       = kernel32.NewProc("LoadLibraryA")
	openProcess        = kernel32.NewProc("OpenProcess")
	writeProcessMemory = kernel32.NewProc("WriteProcessMemory")
	createRemoteThread = kernel32.NewProc("CreateRemoteThread")
	closeHandle        = kernel32.NewProc("CloseHandle")
	virtualAllocEx     = kernel32.NewProc("VirtualAllocEx")
	virtualFreeEx      = kernel32.NewProc("VirtualFreeEx")
	getModuleHandle    = kernel32.NewProc("GetModuleHandle")
)

func main() {
	// parse process ID
	if len(os.Args) < 2 {
		fmt.Println("PID not found :( exiting...")
		return
	}
	pid, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Println("Invalid PID:", os.Args[1])
		return
	}
	fmt.Printf("PID: %#x\n", pid)

	functionName := "GobServer"

	dllHandle, err := syscall.LoadLibrary(targetDll)
	if err != nil {
		fmt.Println("Failed to load DLL:", err)
		return
	}

	fmt.Printf("DLL Handle: %#x\n", dllHandle)

	defer syscall.FreeLibrary(dllHandle)

	functionAddress, err := syscall.GetProcAddress(dllHandle, functionName)
	if err != nil {
		fmt.Println("Failed to get function address:", err)
		return
	}

	offset := uintptr(functionAddress) - uintptr(unsafe.Pointer(dllHandle))

	fmt.Printf("DLL Base Address: %#x\n", uintptr(unsafe.Pointer(dllHandle)))
	fmt.Printf("Function Address: %#x\n", functionAddress)
	fmt.Printf("Function Offset: %#x\n", offset)

	// open process
	ph, op2, err := openProcess.Call(
		PROCESS_ALL_ACCESS,
		FALSE,
		uintptr(pid),
	)

	if err != nil {
		fmt.Println("Results of openProcess:", err)
	}

	if ph == 0 {
		fmt.Println("Failed to open process")
		return
	}
	fmt.Printf("Process handle: %#x\n", ph)
	fmt.Println(op2)
	defer closeHandle.Call(ph)

	rb, va2, err := virtualAllocEx.Call(
		uintptr(ph),
		0,
		uintptr(uintptr(dllLength)*2),
		uintptr(MEM_RESERVE|MEM_COMMIT),
		uintptr(PAGE_READ_WRITE),
	)
	if err != nil {
		fmt.Println("Results of virtualAllocEx:", err)
	}

	if rb == 0 {
		fmt.Println("Failed to allocate memory")
		return
	}
	fmt.Printf("rb: %#x\n", rb)
	fmt.Printf("va2: %#x\n", va2)
	defer virtualFreeEx.Call(
		rb,
		0,
		MEM_RELEASE,
	)

	// write dll to memory
	dllPtr, err := syscall.BytePtrFromString(targetDll)
	wp1, wp2, err := writeProcessMemory.Call(
		ph,
		rb,
		uintptr(unsafe.Pointer(dllPtr)),
		uintptr(dllLength),
		0,
	)

	if err != nil {
		fmt.Println("Results of writeProcessMemory:", err)
	}
	fmt.Printf("wp1: %#x\n", wp1)
	fmt.Printf("wp2: %#x\n", wp2)

	// start new thread to load our dll
	crt1, crt2, err := createRemoteThread.Call(
		ph,
		0,
		0,
		uintptr(loadLibraryA.Addr()),
		rb,
		0,
		0,
	)
	if err != nil {
		fmt.Println("Results of createRemoteThread-1:", err)
	}
	fmt.Printf("crt1: %#x\n", crt1)
	fmt.Printf("crt2: %#x\n", crt2)

	// start new thread - call exported funtion from dll
	crt3, crt4, err := createRemoteThread.Call(
		ph,
		0,
		0,
		functionAddress,    // Pass the address of the function directly
		rb+uintptr(offset), // Add the offset to the base address
		0,
		0,
	)
	if err != nil {
		fmt.Println("Results of createRemoteThread-2:", err)
	}
	fmt.Printf("crt3: %#x\n", crt3)
	fmt.Printf("crt4: %#x\n", crt4)

	// This will keep the golang script alive... if that's what you want.
	// wfso, err := syscall.WaitForSingleObject(syscall.Handle(foo), syscall.INFINITE)
	// if err != nil {
	// 	fmt.Println("Results of WaitForSingleObject", err)
	// }
	// fmt.Println(wfso)

	fmt.Println("\n--- Additional Logging ---")
	fmt.Println("targetDll:", targetDll)
	fmt.Println("dllLength:", dllLength)
	fmt.Printf("dllPtr: %#x\n", uintptr(unsafe.Pointer(dllPtr)))

	fmt.Println("Function called successfully")
}
